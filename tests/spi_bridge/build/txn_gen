#!/usr/bin/env python3

import sys
import random

class FlitFile:
    def __init__(self, filename, width):
        self.output = open(filename, "w")
        self.width = width

    def put(self, data, mask = -1, delay = 0):
        for i in range(self.width - 1, -1, -1):
            v = (data >> i) & 1
            m = (mask >> i) & 1
            if m:
                self.output.write("%d" % v)
            else:
                self.output.write("-")
        self.output.write(" %d\n" % delay)

class Framed(FlitFile):
    def __init__(self, filename):
        FlitFile.__init__(self, filename, 9)
        self.pending = []

    def put(self, frame, delay = 0):
        for i, flit in enumerate(frame):
            try:
                data, mask = flit
            except:
                data, mask = flit, (1 << (self.width - 1)) - 1

            self.pending.append((data, mask, delay))

    def flush(self, delay = 100):
        more = 1 << (self.width - 1)
        for i, (data, mask, fdelay) in enumerate(self.pending):
            last = i + 1 == len(self.pending)

            if not last:
                FlitFile.put(self, data | more, mask | more, fdelay)
            else:
                FlitFile.put(self, data, mask | more, fdelay + delay)

        self.pending = []


class SpiMasterCmd(Framed):
    def div(self, div):
        self.put([0x20 | (div - 1)])

    def select(self, slave):
        self.put([slave])

    def unselect(self):
        self.put([0x1f])

    def shift_out(self, data):
        for offset in range(0, len(data), 0x40):
            chunk = data[offset : offset + 0x40]

            self.put([0x80 | (len(chunk) - 1)])
            self.put(chunk)

    def shift_in(self, data):
        for offset in range(0, len(data), 0x40):
            chunk = data[offset : offset + 0x40]

            self.put([0x40 | (len(chunk) - 1)])

    def shift_io(self, dout, din):
        assert len(dout) == len(din)

        for offset in range(0, len(data), 0x40):
            chunk = dout[offset : offset + 0x40]

            self.put([0xc0 | (len(chunk) - 1)])
            self.put(chunk)

class SpiMasterRsp(Framed):
    def div(self, div):
        self.put([0x20 | (div - 1)])

    def select(self, slave):
        self.put([slave])

    def unselect(self):
        self.put([0x1f])

    def shift_out(self, data):
        for offset in range(0, len(data), 0x40):
            chunk = data[offset : offset + 0x40]

            self.put([0x80 | (len(chunk) - 1)])

    def shift_in(self, data):
        for offset in range(0, len(data), 0x40):
            chunk = data[offset : offset + 0x40]

            self.put([0x40 | (len(chunk) - 1)])
            self.put(chunk)

    def shift_io(self, dout, din):
        assert len(dout) == len(din)

        for offset in range(0, len(data), 0x40):
            chunk = din[offset : offset + 0x40]

            self.put([0xc0 | (len(chunk) - 1)])
            self.put(chunk)

class Master:
    def __init__(self, cmd):
        self.cmd = cmd
        self.div(32)

    def div(self, div):
        self.cmd.div(div)
        self.cmd.flush(50)

    def to_slave(self, data):
        l = len(data) - 1

        self.cmd.select(0)
        self.cmd.shift_out([0x80, l & 0xff, l >> 8])
        self.cmd.shift_out(data)
        self.cmd.unselect()
        self.cmd.flush()

    def from_slave(self, data):
        l = len(data) - 1

        self.cmd.select(0)
        self.cmd.shift_out([0xc0])
        self.cmd.shift_in([l & 0xff, l >> 8])
        self.cmd.shift_in(data)
        self.cmd.unselect()
        self.cmd.flush()

class SlaveReceived(Framed):
    def to_slave(self, data):
        self.put(data)
        self.flush()

    def from_slave(self, data):
        pass

class SlaveTransmitted(Framed):
    def to_slave(self, data):
        pass

    def from_slave(self, data):
        self.put(data)
        self.flush()

if __name__ == "__main__":
    n = sys.argv[1]

    if n == "master_cmd.txt":
        t = Master(SpiMasterCmd(n))
    elif n == "master_rsp.txt":
        t = Master(SpiMasterRsp(n))
    elif n == "slave_received.txt":
        t = SlaveReceived(n)
    elif n == "slave_transmitted.txt":
        t = SlaveTransmitted(n)

    random.seed(42)

    for i in range(10):
        r = random.randint(1, 512)
        size = r >> 1
        direction = r & 1

        if direction:
            t.to_slave(bytes([i & 0xff for i in range(size)]))
        else:
            t.from_slave(bytes([i & 0xff for i in range(size)]))
