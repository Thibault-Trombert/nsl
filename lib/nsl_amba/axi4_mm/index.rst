
AXI4-MM
=======

All AXI4-MM related declarations are scoped in the `nsl_amba.axi4_mm`
package.

Configuration
-------------

Configuration for AXI4-MM is held in `config_t` record type. It holds
the follwing settings:

* Address, data, user, ID width,
* Burst signal support and LEN field width,
* Size field support,
* Region, QoS, Cache, Lock fields availability.

`config()` function can generate such a configuration yet ensuring it
makes sense.

AXI4-MM Lite is the subset where data is either 32 or 64-bit, burst is
unsupported and id cache, region, lock and size signals are excluded.
`is_lite()` can tell whether the configuration
matches these constraints.

Signals
-------

Signals are split in the following records:

* Address (`address_t`), both suitable for master AW and AR channels.
* Write data (`write_data_t`), suitable for master W channel.
* Write response (`write_response_t`), suitable for slave B channel.
* Read data (`read_data_t`), suitable for slave R channel.
* Handshake (`handshake_t`), suitable for slave AW, AR and W channels,
  and slave B and R channels.

Master output port (`master_t`) and slave output port (`slave_t`)
select relevant records above for each of their five channels.

An address channel is written to calling `address()`, all fields are
dereferenced by calling `is_valid()`, `id()`, `address()`,
`length_m1()`, `burst()`, `lock()`, `cache()`, `prot()`, `qos()`,
`region()`, `user()`.

Write data channel is written to calling `write_data()`, all fields
are dereferenced by calling `is_valid()`, `is_last()`, `bytes()`,
`strb()`, `value()`, `mask()`, `user()`.

Write response channel is written to calling `write_response()`, all
fields are dereferenced by calling `is_valid()`, `id()`, `resp()`,
`user()`.

Read data channel is written to calling `read_data()`, all fields are
dereferenced by calling `is_valid()`, `is_last()`, `bytes()`,
`value()`, `id()`, `resp()`, `user()`.

Handshake channel is writted to calling `handshake()`, field is
dereferenced by calling `is_ready()`.

Idle constants for all channels are generated by `address_defaults()`,
`write_data_defaults()`, `write_response_defaults()`,
`read_data_defaults()` and `handshake_defaults()`.

Serializing / getting data
--------------------------

Data vectors are using `nsl_data.bytestream` `byte_string`
type.  Internally, they are stored in records in ascending address
order.  As user often needs to use byte vectors in descending order or
use data on bus as an unsigned value, accessors for data channels
allow to serialize / unserialize byte vectors in either direction and
can serialize / extract unsigned data using either endianness.

For instance, write data serialization function exists in two forms:

.. code-block:: vhdl

   function write_data(cfg: config_t;
                       bytes: byte_string;
                       strb: std_ulogic_vector := na_suv;
                       order: byte_order_t := BYTE_ORDER_INCREASING;
                       user: std_ulogic_vector := na_suv;
                       last: boolean := false;
                       valid: boolean := true)
      return write_data_t;

This version accepts a `bytes` byte_string as data field and a `strb`
vector.  If `strb` is left empty, it defaults to all set.  Both can be
in increasing address order or in decreasing address order depending
on the `order` argument.

.. code-block:: vhdl

   function write_data(cfg: config_t;
                       value: unsigned := na_u;
                       strb: std_ulogic_vector := na_suv;
                       endian: endian_t := ENDIAN_LITTLE;
                       user: std_ulogic_vector := na_suv;
                       last: boolean := false;
                       valid: boolean := true)
      return write_data_t;

This version accepts a `value` unsigned value as data field and a
`strb` vector.  If `strb` is left empty, it defaults to all set.
`value` has MSB on the left of the vector, `strb` has the bit matching
MSB of value on the left.  `endian` argument tells how to serialize
this value as a byte string in the data vector. `strb` will implicitly
be bitswapped accordingly to match data order.

When extracting data from the same `write_data_t`, the following four
functions exit:

.. code-block:: vhdl

  function bytes(cfg: config_t;
                 write_data: write_data_t;
                 order: byte_order_t := BYTE_ORDER_INCREASING)
     return byte_string;

This retrieves the data vector in either byte order.

.. code-block:: vhdl

  function strb(cfg: config_t;
                write_data: write_data_t;
                order: byte_order_t := BYTE_ORDER_INCREASING)
     return std_ulogic_vector;

This retrieves the strobe vector in either byte order, matching data
vector.

.. code-block:: vhdl

  function value(cfg: config_t;
                 write_data: write_data_t;
                 endian: endian_t := ENDIAN_LITTLE)
     return unsigned;

This retrieves the data vector as an unsigned value, as either endianness.

.. code-block:: vhdl

  function mask(cfg: config_t;
                write_data: write_data_t;
                endian: endian_t := ENDIAN_LITTLE)
     return unsigned;

This retrieves the value mask as an unsigned value, as either
endianness (strobe bits are duplicated 8 times to make a mask word).
Of course, in case strobe is not enabled in the configuration, this
returns the relevant default value, which is all set.

Simulation tools
----------------

For simulation purposes, on an AXI4-Lite, there are `lite_write()`,
`lite_read()` and `lite_check()` helpers.  They perform exactly one
beat of transfer on a bus.  They can also be used on full-featured
buses.

For bursts on a full-featured bus, there are `burst_write()`,
`burst_read()` and `burst_check()`.

For usage examples, see `test/amba/axi4_mm_*` test benches
implementation.

Master transactor
-----------------

For bus master needing to read/write constant-sized payloads in
memory, like a DMA scheduler, there exists a `transactor_t`.  It may
be configured once through a `transactor_config_t`.  Transactor
context can be used for either reading or writing.  It will cut read
or write in bursts of relevant lengths.  For an usage example, see
`test/amba/axi_transactor` test bench implementation.

Slave transaction context
-------------------------

For implementing slaves easilly, `transaction_t` helper can handle all
tedious address calculations if needed by configuration (INCR and WRAP
burst modes for instance).  `transaction()` must be given an address
channel beat, and then will iterate over all needed `step()`\s until
it reaches the last beat of transaction.  For an usage example, see
`nsl_amba.ram.axi4_mm_ram_full` implementation.

Serialization tools
-------------------

For easier implementation of fifos and other custom modules, there are
generic helpers to encode/decode all the four channels to
`std_ulogic_vector`\s.  They yield the minimal count of bits to encode
beat, depending on the configuration.

Function isolation
------------------

There are two entities available for abstracting basic bus
interfaces.

* `nsl_amba.axi4_mm.axi4_mm_lite_slave` is an entity taking care of
  the AXI protocol details and gives an uniform synchronous interface
  to backend access in terms of read and write channel, non
  concurrent.

* `nsl_amba.axi4_mm.axi4_mm_lite_regmap` is abstracting even more as
  it:

  * Allows for a limited address space,
  * Limits to a set of full data width registers,
  * Only uses combinatorial reads.

  This is mostly useful for small register maps.
